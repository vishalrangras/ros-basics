	
	Introduction to ROS
	
		Nodes and Topics:
		
			Nodes: On the software side, ROS manages the complex steps of Perception, Decision Making and Actuation by breaking each of them down into many small unix processes called nodes.
			
			Nodes - Typically, each node on the system is responsible for one small and relatively specific portion of the robot's overall functionality.
			
				For e.g., there may be nodes for each sensor and actuator in the system, as well as nodes for things like position estimation, behavior execution and motor control.
				
			ROS Master: At the center of the collection of nodes is the ROS Master which acts as a sort of manager of all the nodes. The ROS Master maintains a registry of all the active nodes on a system. It then allows each node to discover other nodes in the system and establish lines of communication with them.
			
			Parameter Server: In addition to allowing nodes to locate one another and communicate, the ROS Master also hosts what's called the parameter server. The parameter server is typically used to store parameters and configuration values that are shared amongst running nodes.
			
			Topics: Nodes can also share data with one another by passing messages over what are called topics. A topic is simply a named bus which you can think of as a pipe between nodes through which messages flow. This works like asynchronous communication model.
			
				Publish: In order to send a message on a topic, we say that a node must publish to it.
				
				Subscribe: Likewise, to receive a message on a topic, a node must subscribe to it.
				
			Pub-Sub Architecture: The network of nodes connected by topics is called Publish-Subscribe or Pub-Sub Architecture.
			
			Messages: Each ROS Distribution comes with a wide variety of predefined message types which are available for your use.
			
				There are message types for communicating physical quantities, such as positions, velocities, acceleration, rotations, durations, etc. There are also messages for communicating sensor readings such as laser scans, images, point clouds, inertial measurements, and more.
				
			Services: Services allows the passing of messages between nodes and works on Request-Response model. It can be considered as synchronous communication approach. 
			
				Services allows the passing of messages between nodes. However, unlike topic, a service is not a bus and there are no publishers or subscribers associated with it. Nodes interact via services on a one-to-one basis using request and response messages.
			
				By issuing a service call to a service, a node is able to request the information from other node as per service definition. The other node will then respond to the request by sending a message containing the result response.
				
			Compute Graph: The diagrams of nodes and topics and how they're all connected is referred to as compute graph.
			
		ROS Environment:
		
			Environment variables and their meanings:
		
				ROS_ROOT=/opt/ros/kinetic/share/ros The path where core ros packages are stored

				PATH=/opt/ros/kinetic/bin:... The path to the ROS binaries, which we will be using throughout this lesson.

				ROS_DISTRO=kinetic Which distribution of ROS is being used. In this case, we are using kinetic

				PYTHONPATH=/opt/ros/kinetic/lib/python2.7/dist-packages The path to the ROS python packages, which we will be using next lesson.
				
				http://wiki.ros.org/ROS/EnvironmentVariables
				
		ROS Startup Process and some fundamental commands:
		
			1. Start ROS Master Process - `roscore`
			2. Run the required node - `rosrun <<package_name>> <<node_name>>`
			3. To list all the running nodes - `rosnode list`
			4. To list all the running topics - `rostopic list`
			5. To get more information about a particular running topic - `rostopic info <<topic_name>>`
			6. To get message type information of a particular message - `rosmsg show <<Fully_qualified_msg_type_name>>`
			7. To view and edit files in your ros environment - `rosed <<msg_pkg_name>> <<msg_filename>>`
			8. To look at the messages as they are published to a topic - `rostopic echo <<topic_name>>`
			
		ROS Master Process: The master process is responsible for the following:
		
			- Providing naming and registration services to other running nodes
			- Tracking all publishers and subscribers
			- Aggregating log messages generated by the nodes
			- Facilitating connections between nodes
			
	Catkin Workspace & Packages
	
		Steps to create Catkin Workspace:
		
			1. Create workspace_directory/src - `mkdir -p ~/catkin_ws/src`
			2. Navigate to src directory - `cd ~/catkin_ws/src`
			3. Initialize Catkin Workspace - catkin_init_workspace
			4. Return to top level workspace directory - `cd ~/catkin_ws`
			5. To build the workspace - `catkin_make`
			6. You need to source the setup.bash which will be generated in "devel" directory. `source devel/setup.bash`
			
		Roslaunch:
		
			Roslaunch allows you to launch multiple nodes with one simple command, set default parameters in the param server, automatically respawn processes that have died and more. Alternatively, you can launch individual node using `rosrun` command as explained above.
			
			To use `roslaunch` command, you must first make sure that your workspace has been built and sourced.
			
				cd ~/catkin_ws
				catkin_make
				source devel/setup.bash
				roslaunch <<package_name>> <<launch_file_name>>
				
		Rosdep:
		
			The rosdep tool will check for a package's missing dependencies, download them, and install them. In order for the command to work, the workspace must be sourced.
			
			The `rosdep check` will give you a list of system dependencies that are missing, and where to get them.
			
				rosdep check <<package_name>>
			
			The command `rosdep install -i` installs all the missing packages.
			
				rosdep install -i <<package_name>>
			
			In case you still face the issue, use following command to fix swinging arm:
				
				sudo apt-get install ros-kinetic-gazebo-ros-control
			
		Deeper Dive into Packages:
		
			All ROS packages should reside under the `src` directory. To create a ros package, you need to source your environment and then navigate to src directory in your catkin workspace. Then you can create a package using following syntax:
			
				catkin_create_pkg <<your_package_num>> [dependency1 dependency2 ...]
				
			A newly created package contains just two files: CMakeLists.txt and package.xml. This is a minimal working catkin package.
			
			ROS Package Structure:
			
				|	Folder Name		|	Function																						 |
				|																														 |
				|		Executables and Source Files																					 |
				|	scripts			|	Python Executables																				 |
				|	src				|	Source Files																					 |
				|																														 |
				|		Message File Types																								 |
				|	msg				| 	Custom message type definition. Message file have a .msg extension.								 |
				|	srv				|	For call/response type messages. Service messages have .srv extension.							 |
				|																														 |
				|	launch			|	Launch files provide a convenient way of running multiple nodes at once, have .launch extension. |
				|	config			|	Configuration files.																			 |
				
				To browse the list of available packages that can be installed: http://www.ros.org/browse/list.php
				
	Writing ROS Nodes
	
		Simple Arm and Arm Mover Architecture:
		
			Simple Mover Node: The simpler mover node does nothing more than publish joint angle commands to simple arm.
			
			Arm Mover Node: The arm mover node provides a service called safe move, which will allow the arm to be moved to any position within its workspace which has been deemed to be safe. The safe zone is bounded by minimum and maximum joint angles and it's configurable via the ROS parameter server.
			
			Look Away Node: This node subscribes to a topic where camera data is being published. When the camera detects an image with uniform color, meaning that it's looking at the sky, the node will call the safe move service to move the arm to a new position.
			
		ROS Publisher:
		
			Publisher allows a node to send messages to a topic, so that data from the node can be used in other parts of the ROS System.
			
			In Python, ROS publishers typically have the following definition format, although other parameters and arguments are possible too:
			
				`pub1 = rospy.Publisher("/topic_name", message_type, queue_size=size)`
				
					The **/topic_name** indicates which topic the publisher is publishing to.
					
					The **message_type** is indicates the type of the message which is being published.
					
					**queue_size** denotes the maximum number of messages that can be hold up in a queue. The oldest messages are dropped as the queue gets overloaded. If this parameter is set to None or is not used, the rospy.Publisher follows Synchronous Messaging, otherwise it follows Asynchronous Messaging.
					
			Once the publisher has been created as above, a **message** with the specified data type can be published as follow:
			
				`pub1.publish(message)`
				
		Simple Mover Node - simple_mover:
		
			As itâ€™s name implies, this node only has one responsibility, and that is to command joint movements for simple_arm.
			
			To do so, it must publish joint angle command messages to the following topics:

				|	Topic Name				|		/simple_arm/joint_1_position_controller/command			|
				|	Message Type			|		std_msgs/Float64										|
				|	Description	Commands	|		joint 1 to move counter-clockwise, units in radians		|

				|	Topic Name				|		/simple_arm/joint_2_position_controller/command			|
				|	Message Type			|		std_msgs/Float64										|
				|	Description	Commands 	|		joint 2 to move counter-clockwise, units in radians		|
				
			Adding the Scripts Directory:
			
				In order to create a new node in python, you must first create the `scripts` directory within the `simple_arm` package, as it does not exist yet.
				
				In order to allow scripts to be executable, following shell command should be executed:
				
					chmod u+x <<script_name>>
					
			P.S.: Refer to simple_mover script from the code base.
				
			To initialize a client node and register it with the ROS master:
				
				`rospy.init_node('node_name')`
				
				The init_node() function must be called before any other Rospy function can be called.
				
			To create a rate object of a given frequency:
				
				`rate = rospy.Rate(frequency_in_heartz)`
				
				Rates are used to limit the frequency at which certain loops spin in ROS.